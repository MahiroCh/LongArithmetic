# Как запустить

  1) Скачать и распаковать zip куда-нибудь.
  2) В директории проекта отрыть терминал.
  3) Для сборки запустить команду: "make".
  4) Для запуска тестов запустить команду: "make test".
  5) Для запуска расчета числа запустить команду: "make pi". По умолчанию будет подсчитано 100 знаков.
     Иное количество знаков можно указать при запуске так: "make pi *amount_of_digits*".
  6) Для запуска `main.cpp` без аргументов запустить команду: "make runmain".
  7) Почистить директорию от всего, кроме Makefile, .cpp и .hpp можно с помощью: "make clean".

# Технические детали

1) При запуске тестов расчета числа Пи программа выдаст "Failed to calculate Pi correctly." в том случае, если программа не верно посчитает число Пи или что-то другое пойдет не так. В случае успеха выдаст число; авто-проверка корректности подсчета в программее есть. Правда, если попросить посчитать больше 998 знаков, то будет "Failed to calculate Pi correctly.", потому что вшита проверка только до 998 знаков (на деле программа, само собой, может до бесконечности их считать, и скорее всего верно, но я думаю, больше 1000 знаков и не надо нам.

2) Округление чисел в любой системе счисления работает корректно, но конкретно число Пи всегда просто обрезается до нужного числа знаков.

3) Какую-бы точность или округление не выставил пользователь, программа всегда будет отбрасывать ведущие и конечные незначащие нули.

4) Поле precision отвечает за точность в двоичной системе счисления. Она же задается основным конструктором.

5) Во всех операциях итоговая точность результата — наибольшая точность из двух начальных чисел в двоичной системе счисления.

6) Стандартная точность для числа, если ее не задавать напрямую, будет равна 700 знакам после запятой в двоичной системе счисления.

7) Есть функционал не переводить число в двоичную при инициилизации, однако перегрузка операторов работает корректно только для чисел, переведенных в двоичную систему счисления.

8) Все операции реализованы стандартными школьными способами арифметики.

9) Оператор << есть в перегрузке, он всегда выводит число с максимум 50 знаками после запятой.

10) Пользовательские литералы могут выдавать неверные результаты из-за кривости работы функции to_string стандартной библиотеки С++, что вне моего контроля.

11) Метод setBinPrecision может выдавать неожиданные результаты при небольшом кол-ве знаков после запятой, так как это двоичная система и "правильное" округление. Т.е., например, следующий код:
```
LongArithm::DA_BIG a("2.345");
std::cout << a << "\n";
a.setBinPrecision(2);
std::cout << a;
```
выдаст:
```
2.345
2.25
```

> [!IMPORTANT]
> Функционал вычислений случайных выражений из командной строки отсутствует (в ТЗ такого не прописано, поэтому разраб ниче никому не должен), поэтому придется открывать main.cpp, вручную добавлять туда необходимый код и запускать.

# Как работать с main.cpp для проверки программы

При открытии `main.cpp` вас будет ждать такая картина:
```
#include "longArithmetic.hpp"
#include "tests.hpp"

int main(int argc, char* argv[]) {
    
    if (argc > 1) {
        if ((std::string)argv[1] == "test") {
            LongArithmTests::mainTest();
        }
        
        if ((std::string)argv[1] == "pi") {
            int pi_prec = 100;
            if (argc > 2) pi_prec = atoi(argv[2]);
            LongArithmTests::piTest(pi_prec);
        }
    }
}
```

Можно просто добавлять свой код перед телом `main`, после чего запускать это из терминала с помощью: "make runmain".

Пример изменненного кода:
```
#include "longArithmetic.hpp"
#include "tests.hpp"

int main(int argc, char* argv[]) {

    LongArithm::DA_BIG a("2.345");
    std::cout << a << "\n";
    a.setBinPrecision(2);
    std::cout << a;

    if (argc > 1) {
        if ((std::string)argv[1] == "test") {
            LongArithmTests::mainTest();
        }
        
        if ((std::string)argv[1] == "pi") {
            int pi_prec = 100;
            if (argc > 2) pi_prec = atoi(argv[2]);
            LongArithmTests::piTest(pi_prec);
        }
    }
}
```

# Что доступно пользователю
> [!TIP]
> Пользователю доступен функционал setBinPrecision, getAsString, calculatePi.

1) Первая выставляет точность числа в двоичной системе счисления. Принимает один обязательный аргумент — новую точность.
2) Вторая выдает имеющееся число строкой, по умолчанию в десятичной системе счисления с точностью 100 десятичных знаков после запятой (тут сильно влияет, очевидно, то, сколько было задано для числа в двоичной знаков после запятой). Принимает два необязательных аргумента — число десятичных знаков после запятой и дать в двоичной системе (true) или в десятичной (false).
3) Третья выдает число Пи с заданной точность. Принимает один обязательный аргумент — кол-во десятичных знаков после запятой в Пи.


Made by Георгий БПИ241
